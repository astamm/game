% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kmeans.R
\name{kmeans}
\alias{kmeans}
\alias{kmeans.default}
\alias{kmeans.sgd}
\alias{kmeans.gmd}
\title{K-Means Clustering}
\usage{
kmeans(x, ...)

\method{kmeans}{default}(x, centers, iter.max = 10L, nstart = 1L,
  algorithm = c("Hartigan-Wong", "Lloyd", "Forgy", "MacQueen"),
  trace = FALSE)

\method{kmeans}{sgd}(x, k = 2, iter.max = 50L)

\method{kmeans}{gmd}(x, k = 2, iter.max = 50L, d2 = NULL, rule = 2,
  alpha = 0, shift = FALSE)
}
\arguments{
\item{x}{A numeric matrix where each row is a data point or an object that
can be coerced to such a matrix (such as a numeric vector or a data frame
with all numeric columns), an \code{\link{sgd}} object or a
\code{\link{gmd}} object.}

\item{...}{not used.}

\item{centers}{either the number of clusters, say \eqn{k}, or a set of
    initial (distinct) cluster centres.  If a number, a random set of
    (distinct) rows in \code{x} is chosen as the initial centres.}

\item{iter.max}{the maximum number of iterations allowed.}

\item{nstart}{if \code{centers} is a number, how many random sets
    should be chosen?}

\item{algorithm}{character: may be abbreviated.  Note that
    \code{"Lloyd"} and \code{"Forgy"} are alternative names for one
    algorithm.}

\item{trace}{logical or integer number, currently only used in the
    default method (\code{"Hartigan-Wong"}): if positive (or true),
    tracing information on the progress of the algorithm is
    produced.  Higher values may produce more tracing information.}

\item{k}{The number of clusters to look for (default: \code{2L}).}
}
\value{
An object of class \code{"kmeans"} which as a \code{print} and a
  \code{fitted} methods. It is a list with at least the following components:
\describe{
  \item{\code{cluster}}{A vector of integers (among \code{1:k}) indicating
  the cluster to which each point is allocated.}
  \item{\code{centers}}{A matrix of cluster centres.}
  \item{\code{totss}}{The total sum of squares.}
  \item{\code{withinss}}{Vector of within-cluster sum of squares, one
  component per cluster.}
  \item{\code{tot.withinss}}{Total within-cluster sum of squares.}
  \item{\code{betweenss}}{The between-cluster sum of squares.}
  \item{\code{size}}{The number of points in each cluster.}
  \item{\code{iter}}{The number of (outer) iterations.}
  \item{\code{ifault}}{integer: indicator of a possible algorithm problem â€“
  for experts.}
}
}
\description{
This function performs k-means clustering of the data points in a data set.
}
\section{Methods (by class)}{
\itemize{
\item \code{default}: This is the \code{\link[stats]{kmeans}} function of the
\pkg{stats} package. We refer the user to the corresponding documentation
for more details on the available algorithms and examples.

\item \code{sgd}: Implementation for Single Gaussian Data (stored in objects
of class \code{\link{sgd}}).

\item \code{gmd}: Implementation for Gaussian Mixture Data (stored in objects
of class \code{\link{gmd}}).
}}

\examples{
x <- sgd(
  c(mean =  0, precision = 1  ),
  c(mean =  3, precision = 0.5),
  c(mean = -1, precision = 2  )
)
kmeans(x)

N <- 100
M <- 4
w <- matrix(runif(N * M), N, M)
w <- w / rowSums(w)
samp <- tidyr::crossing(
  observation = paste0("O", 1:N),
  component = paste0("C", 1:M)
) \%>\%
dplyr::mutate(mixing = as.numeric(t(w)))
dict <- tibble::tibble(
  component = paste0("C", 1:M),
  mean = numeric(M),
  precision = 1:M
)
x <- gmd(samp, dict)
kx <- kmeans(x)
}
